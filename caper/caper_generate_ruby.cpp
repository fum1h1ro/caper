// Copyright (C) 2014 Katayama Hirofumi MZ.
// All Rights Reserved.

// $Id$

#include "caper_ast.hpp"
#include "caper_error.hpp"
#include "caper_generate_ruby.hpp"
#include "caper_format.hpp"
#include "caper_stencil.hpp"
#include "caper_finder.hpp"
#include <algorithm>
#include <boost/tuple/tuple.hpp>
#include <boost/tuple/tuple_comparison.hpp>

namespace {

std::string make_type_name(const Type& x) {
    switch(x.extension) {
        case Extension::None:
            return x.name;
        case Extension::Star:
        case Extension::Plus:
        case Extension::Slash:
            return "Sequence<" + x.name + ">";
        case Extension::Question:
            return "Optional<" + x.name + ">";
        default:
            assert(0);
            return "";
    }
}
        
void make_signature(
    const std::map<std::string, Type>&      nonterminal_types,
    const tgt::parsing_table::rule_type&    rule,
    const SemanticAction&                   sa,
    std::vector<std::string>&               signature) {
    // function name
    signature.push_back(sa.name);

    // return value
    signature.push_back(
        make_type_name(*finder(nonterminal_types, rule.left().name())));

    // arguments
    for (const auto& arg: sa.args) {
        signature.push_back(make_type_name(arg.type));
    }
}

}

void generate_ruby(
    const std::string&                  src_filename,
    std::ostream&                       os,
    const GenerateOptions&              options,
    const std::map<std::string, Type>&,
    const std::map<std::string, Type>&  nonterminal_types,
    const std::vector<std::string>&     tokens,
    const action_map_type&              actions,
    const tgt::parsing_table&           table) {

    if (options.allow_ebnf) {
        throw unsupported_feature("Ruby", "EBNF");
    }

    std::string namespace_name(options.namespace_name);
    if ('a' <= namespace_name[0] && namespace_name[0] <= 'z')
        namespace_name[0] = namespace_name[0] + 'A' - 'a';

    // notice / URL
    stencil(
        os, R"(
# This file was automatically generated by Caper.
# (http://jonigata.github.io/caper/caper.html)

module ${namespace_name}
)",
        {"namespace_name", namespace_name}
        
        );

    if (!options.external_token) {
        // token enumeration
        stencil(
            os, R"(
    Token = {
$${tokens}
    }

    def self.assert exp, msg = nil
        if ${debug} && !exp
            if msg
                fail msg
            else
                fail
            end
        end
    end

    def self.token_label token
        self.assert Token.has_key? token
        token.to_s
    end

)",
            {"debug", "$DEBUG"},
            {"tokens", [&](std::ostream& os){
                    int index = 0;
                    for(const auto& token: tokens) {
                        stencil(
                            os, R"(
        ${prefix}${token}: ${index},
)",
                            {"prefix", options.token_prefix},
                            {"token", token},
                            {"index", index}
                            );
                        index++;
                    }
                }}
            );
    }

    // nonterminal
    stencil(
        os, R"(
    Nonterminal = {
)"
        );
    {
        int index = 0;
        for (const auto& nonterminal_type: nonterminal_types) {
            stencil(
                os, R"(
        ${nonterminal_name}: ${index},
)",
                {"nonterminal_name", nonterminal_type.first},
                {"index", index}
                );
            index++;
        }
    }
    stencil(
        os, R"(
    }
)"
        );
    
    stencil(
        os, R"(

    class Stack
        attr_accessor :stack, :tmp, :gap

        def initialize
            @stack = []
            @tmp = []
            @gap = 0
        end

        def rollback_tmp
            @gap = @stack.size
            @tmp = []
        end

        def commit_tmp
            @stack.slice! @gap, @stack.size - @gap
            @stack.concat @tmp
            @tmp = []
        end

        def push x
            @tmp.push x
            true
        end

        def pop n
            if @tmp.size < n
                n -= @tmp.size
                @tmp = []
                @gap -= n
            else
                @tmp.slice! @tmp.size - n, n
            end
        end

        def top
            ${namespace_name}::assert 0 < depth
            if @tmp.size != 0
                @tmp[@tmp.size - 1]
            else
                @stack[@gap - 1]
            end
        end

        def get_arg base, index
            n = @tmp.size
            if base - index <= n
                @tmp[n - (base - index)]
            else
                @stack[@gap - (base - n) + index]
            end
        end

        def clear
            @stack = []
            @tmp = []
            @gap = 0
        end

        def empty?
            if 0 < @tmp.size
                false
            else
                @gap == 0
            end
        end

        def depth
            @gap + @tmp.size
        end

        def nth index
            if @gap <= index
                @tmp[index - @gap]
            else
                @stack[index]
            end
        end

        def set_nth index, obj
            if @gap <= index
                @tmp[index - @gap] = obj
            else
                @stack[index] = obj
            end
        end

        def swap_top_and_second
            d = depth
            ${namespace_name}::assert 2 <= d
            x = nth(d - 1)
            set_nth d - 1, nth(d - 2)
            set_nth d - 2, x
        end
    end

    class StackFrame
        attr_accessor :entry, :value, :sequence_length

        def initialize entry, v, sl
            @entry = entry
            @value = v
            @sequence_length = sl
        end
    end

    class TableEntry
        attr_accessor :state, :gotof, :handle_error

        def initialize s, g, he
            @state = s
            @gotof = g
            @handle_error = he
        end
    end

)",
    {"namespace_name", namespace_name}
    );

    // parser
    stencil(
        os, R"(
    class Parser
        attr_accessor :sa, :stack, :accepted, :error, :accepted_value

)"
        );

    // table
    stencil(
        os, R"(
        Entries = [
$${entries}
        ]

        def entry index
            index = 0 if index.class == TrueClass || index.class == FalseClass
            Entries[index]
        end

)",
        {"entries", [&](std::ostream& os) {
                int i = 0;
                for (const auto& state: table.states()) {
                    stencil(
                        os, R"(
            TableEntry.new(:state_${i}, :gotof_${i}, ${handle_error}),
)",
                            
                        {"i", i},
                        {"handle_error", state.handle_error}
                        );
                    ++i;
                }
            }}
        );

    
    stencil(
        os, R"(
        def initialize sa
            @sa = sa
            reset
        end

        def reset
            @error = @accepted = false
            @accepted_value = nil
            clear_stack
            rollback_tmp_stack
            if push_stack(${first_state}, nil, 0)
                commit_tmp_stack
            else
                @sa.stack_overflow
                @error = true
            end
        end

        def post token, value
            rollback_tmp_stack
            @error = false
            while method(stack_top.entry.state).call(token, value)
                ;
            end
            if !@error
                commit_tmp_stack
            else
                recover token, value
            end
            @accepted || @error
        end

        def accept
            return nil if @error
            return true if @accepted_value == nil
            @accepted_value
        end

)",
        {"first_state", table.first_state()}
        );

    // stack operation
    stencil(
        os, R"(
        def push_stack state_index, v = nil, sl = 0
            f = @stack.push(StackFrame.new(entry(state_index), v, sl))
            ${namespace_name}::assert !@error
            if !f
                @error = true
                @sa.stack_overflow
            end
            f
        end

        def pop_stack n
            @stack.pop n
        end

        def stack_top
            @stack.top
        end

        def get_arg base, index
            @stack.get_arg(base, index).value
        end

        def clear_stack
            @stack = Stack.new
        end

        def rollback_tmp_stack
            @stack.rollback_tmp
        end

        def commit_tmp_stack
            @stack.commit_tmp
        end

)",
            {"namespace_name", namespace_name}
        );

    if (options.recovery) {
        stencil(
            os, R"(
        def recover token, value
            rollback_tmp_stack
            @error = false
$${debmes:start}
            while !stack_top.entry.handle_error
                pop_stack 1
                if @stack.empty?
$${debmes:failed}
                    @error = true;
                    return;
                end
            end
$${debmes:done}
            # post error_token;
$${debmes:post_error_start}
            while method(stack_top.entry.state).call(:${recovery_token}, nil)
                ;
            end
$${debmes:post_error_done}
            commit_tmp_stack
            # repost original token
            # if it still causes error, discard it;
$${debmes:repost_start}
            while method(stack_top.entry.state).call(token, value)
                ;
            end
$${debmes:repost_done}
            commit_tmp_stack if !@error
            @error = false if token != :${token_eof}
        end

)",
            {"recovery_token", options.token_prefix + options.recovery_token},
            {"token_eof", options.token_prefix + "eof"},
            {"debmes:start", {
                    options.debug_parser ?
                        R"(        $stderr.print "recover rewinding start: stack depth = " + @stack.depth
)" :
                        ""}},
            {"debmes:failed", {
                    options.debug_parser ?
                        R"(        $stderr.print "recover rewinding failed"
)" :
                        ""}},
            {"debmes:done", {
                    options.debug_parser ?
                        R"(        $stderr.print "recover rewinding done: stack depth = " + @stack.depth
)" :
                        ""}},
            {"debmes:post_error_start", {
                    options.debug_parser ?
                        R"(        $stderr.print "posting error token"
)" :
                        ""}},
            {"debmes:post_error_done", {
                    options.debug_parser ?
                        R"(        $stderr.print "posting error token done"
)" :
                        ""}},
            {"debmes:repost_start", {
                    options.debug_parser ?
                        R"(        $stderr.print "reposting original token"
)" :
                        ""}},
            {"debmes:repost_done", {
                    options.debug_parser ? 
                        R"(        $stderr.print "reposting original token done"
)" :
                        ""}}
            );
    } else {
        stencil(
            os, R"(
        def recover token, value
            ;
        end

)"
            );
    }

    if (options.allow_ebnf) {
        stencil(
            os, R"(
        # EBNF support member functions
        def seq_head nonterminal, base
            # '*': base == 0
            # '+': base == 1
            dest = method(stack_nth_top(base).entry.gotof).call(nonterminal)
            push_stack dest, nil, base
        end
        def seq_trail nonterminal, base
            # '*', '+' trailer
            ${namespace_name}::assert base == 2
            @stack.swap_top_and_second
            stack_top.sequence_length += 1
            true
        end
        def seq_trail2 nonterminal, base
            # '/' trailer
            ${namespace_name}::assert base == 3
            @stack.swap_top_and_second
            pop_stack 1 # erase delimiter
            @stack.swap_top_and_second
            stack_top.sequence_length += 1
            true
        end
        def opt_nothing nonterminal, base
            # same as head of '*'
            ${namespace_name}::assert base == 0
            seq_head nonterminal, base
        end
        def opt_just nonterminal, base
            # same as head of '+'
            ${namespace_name}::assert base == 1
            seq_head nonterminal, base
        end
        def seq_get_range base, index
            # returns beg = end if length = 0 (includes scalar value)
            # distinguishing 0-length-vector against scalar value is
            # caller's responsibility
            n = base - index
            ${namespace_name}::assert 0 < n
            prev_actual_index = 0
            actual_index = @stack.depth
            while (n -= 1) >= 0
                actual_index -= 1
                prev_actual_index = actual_index
                actual_index -= @stack.nth(actual_index).sequence_length
            end
            actual_index..prev_actual_index
        end
        def seq_get_arg base, index
            r = seq_get_range(base, index)
            ${namespace_name}::assert r.end - r.begin == 0
            # multiple value appearing here is not supported now
            @stack.nth(r.begin).value
        end
        def seq_get_seq base, index
            r = seq_get_range(base, index)
            a = []
            for i in r
                a.push @stack.nth(i).value
            end
            a
        end
        def stack_nth_top n
            r = seq_get_range(n + 1, 0)
            # multiple value appearing here is not supported now
            ${namespace_name}::assert r.end - r.begin == 0
            @stack.nth(r.begin)
        end

)",
                {"namespace_name", namespace_name}
            );
    }

    stencil(
        os, R"(
        def call_nothing nonterminal, base
            pop_stack base
            dest_index = method(stack_top.entry.gotof).call(nonterminal)
            push_stack dest_index, nil, 0
        end

)"
        );

    // member function signature -> index
    std::map<std::vector<std::string>, int> stub_indices;
    {
        // member function name -> count
        std::unordered_map<std::string, int> stub_counts; 

        // action handler stub
        for (const auto& pair: actions) {
            const auto& rule = pair.first;
            const auto& sa = pair.second;

            if (sa.special) {
                continue;
            }

            // make signature
            std::vector<std::string> signature;
            make_signature(
                nonterminal_types,
                rule,
                sa,
                signature);

            // skip duplicated
            if (0 < stub_indices.count(signature)) {
                continue;
            }

            // make function name
            if (stub_counts.count(sa.name) == 0) {
                stub_counts[sa.name] = 0;
            }
            int stub_index = stub_counts[sa.name];
            stub_indices[signature] = stub_index;
            stub_counts[sa.name] = stub_index+1;

            // header
            stencil(
                os, R"(
        def call_${stub_index}_${sa_name} nonterminal, base${args}
)",
                {"stub_index", stub_index},
                {"sa_name", sa.name},
                {"args", [&](std::ostream& os) {
                        for (size_t l = 0 ; l < sa.args.size() ; l++) {
                            os << ", arg_index" << l;
                        }
                    }}
                );

            // check sequence conciousness
            std::string get_arg = "get_arg";
            for (const auto& arg: sa.args) {
                if (arg.type.extension != Extension::None) {
                    get_arg = "seq_get_arg";
                    break;
                }
            }

            // automatic argument conversion
            for (size_t l = 0 ; l < sa.args.size() ; l++) {
                const auto& arg = sa.args[l];
                if (arg.type.extension == Extension::None) {
                    stencil(
                        os, R"(
            arg${index} = @sa.downcast(${get_arg}(base, arg_index${index}))
)",
                        {"get_arg", get_arg},
                        {"index", l}
                        );
                } else {
                    stencil(
                        os, R"(
            arg${index} = @sa.downcast(seq_get_arg(base, arg_index${index}))
)",
                        {"index", l}
                        );
                }
            }

            // semantic action / automatic value conversion
            stencil(
                os, R"(
            v = @sa.upcast(@sa.${semantic_action_name}(${args}))
            pop_stack base
            dest_index = method(stack_top.entry.gotof).call(nonterminal)
            push_stack dest_index, v, 0
        end

)",
                {"semantic_action_name", sa.name},
                {"args", [&](std::ostream& os) {
                        bool first = true;
                        for (size_t l = 0 ; l < sa.args.size() ; l++) {
                            if (first) { first = false; }
                            else { os << ", "; }
                            os << "arg" << l;
                        }
                    }}
                );
        }
    }

    // states handler
    for (const auto& state: table.states()) {
        // state header
        stencil(
            os, R"(
        def state_${state_no} token, value
$${debmes:state}
            case token
)",
            {"state_no", state.no},
            {"debmes:state", [&](std::ostream& os){
                    if (options.debug_parser) {
                        stencil(
                            os, R"(
            $stderr.print("state_${state_no} << " + token_label(token));
)",
                            {"state_no", state.no}
                            );
                    }}}
            );

        // reduce action cache
        typedef boost::tuple<
            std::vector<std::string>,
            std::string,
            size_t,
            std::vector<int>>
            reduce_action_cache_key_type;
        typedef 
            std::map<reduce_action_cache_key_type,
                     std::vector<std::string>>
            reduce_action_cache_type;
        reduce_action_cache_type reduce_action_cache;

        // action table
        for (const auto& pair: state.action_table) {
            const auto& token = pair.first;
            const auto& action = pair.second;

            const auto& rule = action.rule;

            // action header 
            std::string case_tag =
                options.token_prefix + tokens[token];

            // action
            switch (action.type) {
                case zw::gr::action_shift:
                    stencil(
                        os, R"(
            when :${case_tag}
                # shift
                push_stack ${dest_index}, value, 0
                false
)",
                        {"case_tag", case_tag},
                        {"dest_index", action.dest_index}
                        );
                    break;
                case zw::gr::action_reduce: {
                    size_t base = rule.right().size();
                    const std::string& rule_name = rule.left().name();

                    auto k = finder(actions, rule);
                    if (k && !(*k).special) {
                        const auto& sa = *k;

                        std::vector<std::string> signature;
                        make_signature(
                            nonterminal_types,
                            rule,
                            sa,
                            signature);

                        reduce_action_cache_key_type key =
                            boost::make_tuple(
                                signature,
                                rule_name,
                                base,
                                sa.source_indices);

                        reduce_action_cache[key].push_back(case_tag);
                    } else {
                        stencil(
                            os, R"(
            when :${case_tag}
)",
                            {"case_tag", case_tag}
                            );
                        std::string funcname = "call_nothing";
                        if (k) {
                            const auto& sa = *k;
                            assert(sa.special);
                            funcname = sa.name;
                        }
                        stencil(
                            os, R"(
                # reduce
                return ${funcname}(:${nonterminal}, ${base})
)",
                            {"funcname", funcname},
                            {"nonterminal", rule.left().name()},
                            {"base", base}
                            );
                    }
                }
                    break;
                case zw::gr::action_accept:
                    stencil(
                        os, R"(
            when :${case_tag}
                # accept
                @accepted = true
                @accepted_value = get_arg(1, 0)
                false
)",
                        {"case_tag", case_tag}
                        );
                    break;
                case zw::gr::action_error:
                    stencil(
                        os, R"(
            when :${case_tag}
                ${namespace_name}::assert false
                @sa.syntax_error
                @error = true
                false
)",
                        {"case_tag", case_tag},
                        {"namespace_name", namespace_name}
                        );
                    break;
            }

            // action footer
        }

        // flush reduce action cache
        for(const auto& pair: reduce_action_cache) {
            const reduce_action_cache_key_type& key = pair.first;
            const std::vector<std::string>& cases = pair.second;

            const std::vector<std::string>& signature = key.get<0>();
            const std::string& nonterminal_name = key.get<1>();
            size_t base = key.get<2>();
            const std::vector<int>& arg_indices = key.get<3>();

            stencil(
                os, R"(
            when :${case})",
                    {"case", cases[0]}
            );

            for (size_t j = 1 ; j < cases.size() ; j++){
                // fall through, be aware when port to other language
                stencil(
                    os, R"(, :${case})",
                    {"case", cases[j]}
                    );
            }

            stencil(
                os, R"(

)"
            );

            int index = stub_indices[signature];

            stencil(
                os, R"(
                # reduce
                call_${index}_${sa_name} :${nonterminal}, ${base}${args}
)",
                {"index", index},
                {"sa_name", signature[0]},
                {"nonterminal", nonterminal_name},
                {"base", base},
                {"args", [&](std::ostream& os) {
                        for(const auto& x: arg_indices) {
                            os  << ", " << x;
                        }
                    }}
                );
        }

        // dispatcher footer / state footer
        stencil(
            os, R"(
            else
                @sa.syntax_error
                @error = true
                false
            end
        end

)"
            );
        
        // gotof header
        stencil(
            os, R"(
        def gotof_${state_no} nonterminal
)",
            {"state_no", state.no}
            );
            
        // gotof dispatcher
        std::stringstream ss;
        stencil(
            ss, R"(
            case nonterminal
)"
            );
        bool output_switch = false;
        for (const auto& pair: state.goto_table) {
            stencil(
                ss, R"(
            when :${nonterminal}
                ${state_index}
)",
                {"nonterminal", pair.first.name()},
                {"state_index", pair.second}
                );
            output_switch = true;
        }

        // gotof footer
        stencil(
            ss, R"(
            else
                ${namespace_name}::assert false
                false
            end
)",
                {"namespace_name", namespace_name}
            );
        if (output_switch) {
            os << ss.str();
        } else {
            stencil(
                os, R"(
            ${namespace_name}::assert false
            true
)",
                {"namespace_name", namespace_name}
            );
        }
        stencil(os, R"(
        end

)"
            );
    }
    stencil(os, R"(
    end
end
)"
        );
}
